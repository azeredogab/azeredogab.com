{"componentChunkName":"component---src-templates-blog-post-js","path":"/php-8-e-a-entrada-do-JIT/","result":{"data":{"site":{"siteMetadata":{"title":"azeredogab"}},"markdownRemark":{"id":"a389b9b6-86ab-58c6-b18a-5a50d0e7a352","excerpt":"Se você é desenvolvedor PHP a algum tempo e gosta de acompanhar as novidades da linguagem, provavelmente já ouviu falar que o compilador JIT será adicionado no…","html":"<p>Se você é desenvolvedor PHP a algum tempo e gosta de acompanhar as novidades da linguagem, provavelmente já ouviu falar que o compilador JIT será adicionado no PHP 8. Se não ouviu, essa foi a <a href=\"https://wiki.php.net/rfc/jit#proposed_voting_choices\">votação</a> que tornou isso realidade. 90% dos core contributors votaram para essa feature entrasse no PHP 8. Desde o PHP 7 tivemos várias mudanças com o foco em aumento de perfomance, mas creio que esse seja um grande avanço na linguagem. Essa feature é bem grande e seu desenvolvimento foi iniciado a 2 anos atrás, sendo que ainda temos mais 1 ano até o lançamento do PHP 8. Nesse artigo vamos entrar um pouco no que teremos com esse novo avanço. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5a676de0613ce06d5288b5e9ce12b78a/2bef9/o-que-php-1024x512.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 50%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAIAAAA7N+mxAAAACXBIWXMAAAsSAAALEgHS3X78AAAAzUlEQVQoz2PonHyQaHQATYQBiDsmHSBGM1AZBKFohkvA2WDyYPe0I8g60QzCqhlEtk/cB+TWtm1o7t3VMXE/qh6E/Qwwew7AGT3TjuaVzYlMqHfxTAyLrY5KaIhPbcPqEQY0z3RM2t8z/VhQRElgeHFCWkdwZLmLZ1Ja7oSuKYcgjoKpxO5sEKpoWNk+cX/fzJONXVtrWzf0Tj8GD2qUAINqQ9XcO/0o2Of7u6Yc7pl2BFd0MKBFAHIQwM1FthDubCDJgBbOWCMGM5IgigEyZGuRv4HQkAAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"PHP\"\n        title=\"PHP\"\n        src=\"/static/5a676de0613ce06d5288b5e9ce12b78a/fcda8/o-que-php-1024x512.png\"\n        srcset=\"/static/5a676de0613ce06d5288b5e9ce12b78a/12f09/o-que-php-1024x512.png 148w,\n/static/5a676de0613ce06d5288b5e9ce12b78a/e4a3f/o-que-php-1024x512.png 295w,\n/static/5a676de0613ce06d5288b5e9ce12b78a/fcda8/o-que-php-1024x512.png 590w,\n/static/5a676de0613ce06d5288b5e9ce12b78a/efc66/o-que-php-1024x512.png 885w,\n/static/5a676de0613ce06d5288b5e9ce12b78a/2bef9/o-que-php-1024x512.png 1024w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span> </p>\n<h2>O que é o JIT ?</h2>\n<p>Talvez você não tenha ouvido falar sobre o JIT antes, então vou dar uma explicação rápida. Você provavelmente já sabe que o PHP é uma linguagem insterpretada, isso significa que o código não necessáriamente é compilado antes de rodar (como o C/C++). Ao invés disso, a engine do PHP irá ler o seu código e roda-lo. Em outras palavras, você cria código de script e dá isso para o PHP rodar.</p>\n<p>PHP possui uma maquina virtual chamada Zend VM. Ela é responsável por ler e rodar o seu código PHP, mas antes disso, o seu código será lido e transformado em OPCode, que é a linguagem que a Zend VM entende. </p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/62fec0b0f99aeebbdbf6b2c00d762b22/5a190/JIT-example.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 22.972972972972975%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAIAAADKYVtkAAAACXBIWXMAAAsSAAALEgHS3X78AAAAqElEQVQY05VPzQqEIBj0/R/KQ9Cli+Ahtw4R9mNJKGRQmegOdVn2sLBzGIZhdOYjTdOs65pSijGmP0G01pRS733XdcMwHMehbyilwPM8b9vmnJumCRrmsiznee77fl0XQS3KkcNLJOq6Hsex73vGmJQSom1bcFmWQgjOeVVV1tosy15CkDzPi6IIITxLIIwx9gM4ByUohA/GCsQwE1+TcOPHwfHGl/OIN6SWGjuo1zTLAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Demonstração\"\n        title=\"Demonstração\"\n        src=\"/static/62fec0b0f99aeebbdbf6b2c00d762b22/fcda8/JIT-example.png\"\n        srcset=\"/static/62fec0b0f99aeebbdbf6b2c00d762b22/12f09/JIT-example.png 148w,\n/static/62fec0b0f99aeebbdbf6b2c00d762b22/e4a3f/JIT-example.png 295w,\n/static/62fec0b0f99aeebbdbf6b2c00d762b22/fcda8/JIT-example.png 590w,\n/static/62fec0b0f99aeebbdbf6b2c00d762b22/5a190/JIT-example.png 800w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span> </p>\n<p>Sendo assim, nós precisamos de um primeiro passo de compilação e então outro passo de interpretação, como exemplificado na imagem acima. Para ganhar performance, nós temos o chamado OPCache (OPCode Cache), que guarda o resultado da compilação para que não seja necessário compilar novamente da próxima vez. </p>\n<p>O PHP irá funcionar de maneira um pouco diferente a partir de agora. Por baixo dos panos o PHP utilizará uma biblioteca chamada Dynamic Assembler <a href=\"https://luajit.org/dynasm.html\">DynASM</a>. Essa biblioteca foi desenvolvida inicialmente para ser o compilador JIT da linguagem Lua, mas também é possível utiliza-la para outras projetos. Esse foi o caso do PHP. Utilizando isso, o PHP é capaz de transformar os OPCodes em códigos de maquina específicos. Assim, o PHP consegue “pular” a etapa de interpretar o código feita pela Zend VM e o executa diretamente.</p>\n<p>Mas será que fica realmente rápido ? </p>\n<p>Esse vídeo abaixo mostra uma comparação entre o PHP com o compilador JIT e a versão anterior (sem o JIT). </p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube.com/embed/dWH65pmnsrI\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>Nesse exemplo do vídeo, o PHP foi utilizado para criar uma imagem 3D. Sabemos que esse não é o uso comum da linguagem. Esse exemplo foi dado porque agora nosso código é compilado em linguagem de máquina e roda diretamente pela CPU, ao invés de passar pelo interpretador, então o principal ganho de performance é relacionado ao uso de CPU. Se fosse feito um teste com uma aplicação web padrão, normalmente dependeria de I/O (Banco de dados, Upload de arquivos, Requests HTTP e etc). Então, para obter um resultado “limpo”, foi colocado esse cenário de renderização de imagem 3D. </p>\n<p>Desde o PHP 7.0, o tópico <code class=\"language-text\">performance</code> tem sido mais abordado do que nunca, em parte graças à competição com o HHVM do facebook (que também tem um compilador JIT). Várias aspectos da linguagem como OPCache, estruturas de dados, e etc estão sendo otimizados pouco a pouco. Hoje, chegamos em um ponto onde não há mais muita coisa que iria trazer um aumento significativo de desempenho nesses tópicos.  </p>\n<p>Além disso, a performance do PHP para uma linguagem de servidor pode ser considerado muito boa, esquecendo o PHP lento do passado. Então agora podemos pensar em expandir as capacidades do PHP para novas áreas como análise de dados, renderização 3D / 2D e mais. </p>\n<p>No passado, código de alta performance era escrito com extensões C/C++ ao invés de pacotes PHP normais. Por exemplo, o <code class=\"language-text\">phpredis</code> é 6-7 vezes mais rápido do que o <code class=\"language-text\">predis</code>. Se o código PHP é compilado ao invés de interpretado, nós teremos pacotes PHP com a mesma performance de extensões escritas em C/C++. </p>\n<p>Agora vamos a um experimento: </p>\n<p>Para conseguirmos realizar esse teste da forma mais prática possível, iremos utilizar essa imagem docker (akondas/php:8.0-cli-alpine). Nesse experimento iremos rodar uma simples função de fibonacci. </p>\n<p>Com o docker já instalado e configurado na sua maquina, podemos criar uma função fibonacci chamada <code class=\"language-text\">fibo.php</code>, com o código a seguir: </p>\n<div class=\"gatsby-highlight\" data-language=\"php\"><pre class=\"language-php\"><code class=\"language-php\"><span class=\"token keyword\">function</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$n</span> <span class=\"token operator\">&lt;</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">?</span> <span class=\"token number\">1</span> <span class=\"token punctuation\">:</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$n</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$n</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token variable\">$n</span> <span class=\"token operator\">=</span> <span class=\"token number\">32</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$start</span> <span class=\"token operator\">=</span> <span class=\"token function\">microtime</span><span class=\"token punctuation\">(</span><span class=\"token boolean constant\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$fibonacci</span> <span class=\"token operator\">=</span> <span class=\"token function\">fibonacci</span><span class=\"token punctuation\">(</span><span class=\"token variable\">$n</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token variable\">$stop</span> <span class=\"token operator\">=</span> <span class=\"token function\">microtime</span><span class=\"token punctuation\">(</span><span class=\"token boolean constant\">true</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">echo</span> <span class=\"token function\">sprintf</span><span class=\"token punctuation\">(</span><span class=\"token double-quoted-string string\">\"Fibonacci(%s): %s\\nTime: %s\"</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$n</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$fibonacci</span><span class=\"token punctuation\">,</span> <span class=\"token variable\">$stop</span><span class=\"token operator\">-</span><span class=\"token variable\">$start</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>Agora iremos rodar essa função, executando primeiro em um contrainer PHP 8, mas sem o JIT habilitado. Para fazer isso utilize o comando: </p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run -it -v <span class=\"token string\">\"<span class=\"token environment constant\">$PWD</span>\"</span>:/usr/src/app -w /usr/src/app <span class=\"token punctuation\">\\</span>\nakondas/php:8.0-cli-alpine php fibo.php\n\nFibonacci<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span>: <span class=\"token number\">3524578</span>\nTime: <span class=\"token number\">0.17796015739441</span> </code></pre></div>\n<p>Para fianlizar o nosso teste, iremos rodar agora com o JIT habilitado e vamos ver o que acontece.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\">docker run -it -v <span class=\"token string\">\"<span class=\"token environment constant\">$PWD</span>\"</span>:/usr/src/app -w /usr/src/app <span class=\"token punctuation\">\\</span>\nakondas/php:8.0-cli-alpine php -dzend_extension<span class=\"token operator\">=</span>opcache.so <span class=\"token punctuation\">\\</span>\n-dopcache.enable_cli<span class=\"token operator\">=</span><span class=\"token number\">1</span> -dopcache.jit_buffer_size<span class=\"token operator\">=</span><span class=\"token number\">500000000</span> <span class=\"token punctuation\">\\</span>\n-dopcache.jit<span class=\"token operator\">=</span><span class=\"token number\">1235</span> fibo.php\n\nFibonacci<span class=\"token punctuation\">(</span><span class=\"token number\">32</span><span class=\"token punctuation\">)</span>: <span class=\"token number\">3524578</span>\nTime: <span class=\"token number\">0.050444841384888</span></code></pre></div>\n<p>Como podemos ver, a diferença é impressionante. <code class=\"language-text\">0.1779</code> vs <code class=\"language-text\">0.0504</code>. Com o JIT habilitado tivemos um aumento de <code class=\"language-text\">252%</code> na execução.</p>\n<p>Certamente o JIT será uma melhoria que irá beneficiar muito o ecosistema PHP, então, vamos aproveitar! </p>\n<h3>Referências:</h3>\n<p>Esse texto é uma tradução/adaptação dos seguintes artigos: </p>\n<ul>\n<li>🙏 <a href=\"https://medium.com/jp-tech/try-out-jit-compiler-with-php-8-0-a020e6aeb3e5\">https://medium.com/jp-tech/try-out-jit-compiler-with-php-8-0-a020e6aeb3e5</a></li>\n<li>🙏 <a href=\"https://arkadiuszkondas.com/how-to-run-php-8-with-jit-support-using-docker/\">https://arkadiuszkondas.com/how-to-run-php-8-with-jit-support-using-docker/</a></li>\n</ul>\n<p>Aos autores meu agradecimento pelo conteúdo de qualidade.</p>","frontmatter":{"title":"PHP 8 e a entrada do JIT","date":"05/01/2020","description":"Vamos entender como é o funcionamento do por trás do JIT (Just in Time Compiler), uma nova feature que promote aumentar muito a performance do PHP 8.","image":"/php-8-e-a-entrada-do-JIT/facebook-share.jpg","tags":["development"]},"fields":{"slug":"/php-8-e-a-entrada-do-JIT/"}}},"pageContext":{"slug":"/php-8-e-a-entrada-do-JIT/","previous":{"fields":{"slug":"/acessando-cookies-do-front-end-com-laravel/"},"frontmatter":{"title":"Acessando Cookies do Front end com Laravel"}},"next":null}}}